================================================================================
                    SMART DINE - MACHINE LEARNING ARCHITECTURE
                           COMPREHENSIVE DOCUMENTATION
================================================================================

PROJECT OVERVIEW:
Smart Dine is a Hybrid Context-Aware Food and Restaurant Recommendation System
that combines multiple ML techniques including Content-Based Filtering, 
Collaborative Filtering, Sentiment Analysis, Health-Aware Personalization,
and Location-Based Ranking to provide intelligent food recommendations.

================================================================================
                              ML COMPONENTS ANALYSIS
================================================================================

1. HYBRID RECOMMENDER SYSTEM (hybrid_recommender.py)
================================================================================

WHAT IT IS:
A sophisticated recommendation engine that combines multiple ML approaches to 
generate final food recommendations by merging Content-Based Filtering, 
Collaborative Filtering, and Popularity-Based scoring.

WHY IT'S USED:
- Overcomes limitations of individual recommendation approaches
- Reduces cold start problem by combining multiple signals
- Provides more robust and diverse recommendations
- Balances personalization with popular choices

ALGORITHMS USED:
1. TF-IDF Vectorization for content analysis
2. Cosine Similarity for measuring item relationships
3. Weighted Linear Combination for score fusion

HOW SCORES ARE CALCULATED:
Final Score = 0.5 × Content_Score + 0.3 × CF_Score + 0.2 × Popularity_Score

DETAILED PARAMETER BREAKDOWN:

1. Content_Score Calculation:
   - Uses MenuItem fields: name, description, cuisine, isVeg, spicinessLevel
   - Text = f"{item.name} {item.description} {'veg' if item.isVeg else 'non-veg'} {'spicy ' * item.spicinessLevel}"
   - TF-IDF vectorization converts text to numerical features
   - Cosine similarity between target item and all menu items
   - Range: 0.0 to 1.0 (1.0 = identical items)

2. CF_Score Calculation:
   - Uses Review collection: rating field (1-5 scale)
   - Rating ≥ 4 → Score = 1.0 (strong positive signal)
   - Rating = 3 → Score = 0.5 (neutral signal)
   - Rating < 3 → Ignored (negative feedback filtered out)
   - Creates user-item interaction matrix from restaurantId mappings
   - Range: 0.0 to 1.0

3. Popularity_Score Calculation:
   - Uses Restaurant.rating field (aggregated from all reviews)
   - Formula: Restaurant.rating / 5.0
   - Example: 4.2-star restaurant → 0.84 popularity score
   - Range: 0.0 to 1.0 (normalized from 1-5 star scale)

WHY SCORES ARE IMPORTANT:
- Provides balanced recommendations considering multiple factors
- Ensures both personalized and generally popular items are recommended
- Allows fine-tuning of recommendation strategy through weight adjustment

CONTRIBUTION TO APPLICATION:
- Core recommendation engine powering the main food suggestions
- Enables personalized user experience while maintaining quality
- Supports real-time recommendation generation

TECHNICAL NOTES:
- Uses MongoDB for data persistence
- Implements sparsity reduction techniques for CF
- Normalizes scores to 0-1 range for consistent weighting

================================================================================

2. CONTENT-BASED FILTERING (content_based.py)
================================================================================

WHAT IT IS:
A recommendation system that suggests items similar to those a user has 
previously interacted with, based on item features and descriptions.

WHY IT'S USED:
- Works well for new users (no cold start problem)
- Provides explainable recommendations
- Doesn't require user interaction data
- Good for niche preferences

ALGORITHMS USED:
1. TF-IDF (Term Frequency-Inverse Document Frequency) Vectorization
2. Cosine Similarity for measuring content similarity

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Feature Extraction from MenuItem Schema:
   - item.name: "Chicken Biryani", "Masala Dosa", etc.
   - item.description: "Aromatic basmati rice with spiced chicken"
   - item.cuisine: "South Indian", "North Indian", "Chinese"
   - item.isVeg: Boolean → converted to "veg" or "non-veg" text
   - item.spicinessLevel: 0-4 scale → repeated "spicy" keywords

2. Text Combination Example:
   Input: {name: "Chicken Biryani", description: "Aromatic rice", isVeg: false, spicinessLevel: 3}
   Output: "Chicken Biryani Aromatic rice non-veg spicy spicy spicy"

3. TF-IDF Vectorization:
   - Converts combined text into numerical feature vectors
   - Each word gets weighted by frequency and rarity
   - Creates sparse matrix of size [n_items × vocabulary_size]

4. Cosine Similarity Formula:
   Similarity(A,B) = (A·B) / (||A|| × ||B||)
   - A, B = TF-IDF vectors for two menu items
   - Dot product measures feature overlap
   - Normalization ensures 0-1 range regardless of text length
   - Example: "Chicken Curry" vs "Mutton Curry" = 0.85 similarity

WHY SCORES ARE IMPORTANT:
- Higher scores indicate more similar items
- Enables finding items with similar characteristics
- Provides basis for "more like this" recommendations

CONTRIBUTION TO APPLICATION:
- Handles new user recommendations
- Provides similar dish suggestions
- Supports dietary preference filtering (veg/non-veg)

TECHNICAL NOTES:
- Uses English stop words removal
- Handles missing data gracefully
- Scalable to large menu databases

================================================================================

3. COLLABORATIVE FILTERING (collaborative_filtering.py)
================================================================================

WHAT IT IS:
A recommendation approach that predicts user preferences based on the 
collective behavior and preferences of similar users.

WHY IT'S USED:
- Discovers hidden patterns in user behavior
- Provides serendipitous recommendations
- Leverages wisdom of crowds
- Effective for popular items

ALGORITHMS USED:
1. User-Item Matrix Construction
2. Cosine Similarity for user similarity computation
3. Implicit Feedback Processing

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Rating Conversion from Review Schema:
   - Uses Review.rating field (1-5 integer scale)
   - Review.rating = 5 → Implicit Score = 1.0 (loved it)
   - Review.rating = 4 → Implicit Score = 1.0 (liked it)
   - Review.rating = 3 → Implicit Score = 0.5 (neutral)
   - Review.rating = 1,2 → Filtered out (negative feedback ignored)
   - Maps Review.restaurantId to MenuItem.restaurantId for item-level scoring

2. User-Item Matrix Construction:
   - Rows: Unique Review.userId values
   - Columns: Unique Review.restaurantId values
   - Cell values: Converted implicit scores (0, 0.5, or 1.0)
   - Example matrix: User123 × Restaurant456 = 1.0 (user loved this restaurant)

3. User Similarity Calculation:
   - Compares user preference vectors using cosine similarity
   - Example: User A [1,0,1,0.5] vs User B [1,0.5,1,0] = 0.87 similarity
   - Identifies users with similar taste patterns

4. Recommendation Score Formula:
   Score(target_user, restaurant) = Σ(similarity(target_user, similar_user) × rating(similar_user, restaurant))
   - Weighted average of similar users' preferences
   - Higher weight given to more similar users

WHY SCORES ARE IMPORTANT:
- Identifies users with similar tastes
- Predicts preferences for unrated items
- Enables discovery of new preferences

CONTRIBUTION TO APPLICATION:
- Provides personalized recommendations based on community behavior
- Handles preference evolution over time
- Supports social proof in recommendations

TECHNICAL NOTES:
- Implements sparsity reduction for better performance
- Uses implicit feedback (ratings as interactions)
- Handles cold start with synthetic interactions

================================================================================

4. HEALTH-AWARE RECOMMENDER (health_aware_recommender.py)
================================================================================

WHAT IT IS:
A specialized recommendation system that considers user health conditions,
dietary restrictions, and nutritional goals when suggesting food items.

WHY IT'S USED:
- Promotes healthy eating habits
- Accommodates medical dietary restrictions
- Supports fitness and wellness goals
- Provides personalized nutrition guidance

ALGORITHMS USED:
1. Rule-Based Health Constraint System
2. Content-Based Similarity with Health Penalties
3. Multi-Criteria Decision Making

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Base Score Calculation:
   - Uses Content-Based similarity as foundation
   - Combines MenuItem fields: name, description, cuisine
   - Range: 0.0 to 1.0

2. Health Constraint Parameters from User Schema:
   
   A) Calorie Management:
   - MenuItem.calories: Actual calorie content (e.g., 450 calories)
   - User.preferences.calorieGoal: Daily target (default: 2000)
   - Penalty: -0.15 if MenuItem.calories > User.preferences.calorieGoal
   - Example: 2500-calorie dish for 2000-goal user → -0.15 penalty
   
   B) Diabetes Condition:
   - User.health.conditions array contains "diabetes"
   - MenuItem.calories threshold: 400 calories
   - Penalty: -0.2 if ("diabetes" in User.health.conditions AND MenuItem.calories > 400)
   - Example: 500-calorie biryani for diabetic user → -0.2 penalty
   
   C) Blood Pressure Condition:
   - User.health.conditions array contains "bp" or "hypertension"
   - MenuItem.spicinessLevel: 0-4 scale (4 = very spicy)
   - Penalty: -0.15 if ("bp" in User.health.conditions AND MenuItem.spicinessLevel ≥ 4)
   - Example: Level-4 spicy curry for BP patient → -0.15 penalty

3. Final Score Formula:
   Final Score = Base_Score + Calorie_Adjustment + Diabetes_Adjustment + BP_Adjustment
   - All adjustments are negative (penalties only)
   - Ensures health-conscious recommendations
   - Range: Typically 0.0 to 1.0 (can go slightly negative for very unhealthy options)

WHY SCORES ARE IMPORTANT:
- Ensures recommendations align with health goals
- Prevents harmful food suggestions for medical conditions
- Balances taste preferences with health requirements

CONTRIBUTION TO APPLICATION:
- Enables health-conscious food recommendations
- Supports users with dietary restrictions
- Promotes responsible eating habits
- Differentiates app from generic food apps

TECHNICAL NOTES:
- Implements hard constraints (filtering) and soft constraints (scoring)
- Supports multiple health conditions simultaneously
- Extensible for new health rules

================================================================================

5. SENTIMENT ANALYSIS (sentiment_analysis.py)
================================================================================

WHAT IT IS:
A Natural Language Processing system that analyzes restaurant reviews to 
determine customer sentiment and overall restaurant quality perception.

WHY IT'S USED:
- Captures qualitative aspects of restaurant experience
- Provides emotional context beyond numerical ratings
- Identifies trending positive/negative opinions
- Enhances recommendation quality with sentiment insights

ALGORITHMS USED:
1. VADER (Valence Aware Dictionary and sEntiment Reasoner) Sentiment Analyzer
2. Compound Sentiment Scoring
3. Aggregation and Normalization

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Individual Review Processing:
   - Input: Review.reviewText field (string)
   - Example: "Amazing food! Great service and ambiance. Highly recommend!"
   - VADER Analyzer processes text and returns compound score
   - Compound Score range: -1.0 (very negative) to +1.0 (very positive)
   - Example scores:
     * "Terrible food, worst experience" → -0.8
     * "Good food, decent service" → +0.4
     * "Outstanding! Best restaurant ever!" → +0.9

2. Restaurant-Level Aggregation:
   - Groups all Review documents by Review.restaurantId
   - Calculates mean of all compound scores for each restaurant
   - Formula: Restaurant_Sentiment = Σ(compound_scores) / count(reviews)
   - Example: Restaurant with scores [0.8, 0.6, 0.9, 0.7] → Average = 0.75

3. Sentiment Classification Logic:
   - Positive: Restaurant_Sentiment > 0.2 (generally positive reviews)
   - Neutral: -0.2 ≤ Restaurant_Sentiment ≤ 0.2 (mixed reviews)
   - Negative: Restaurant_Sentiment < -0.2 (generally negative reviews)

4. Database Storage:
   - Calculated sentiment stored in Restaurant.sentimentScore field
   - Updates Restaurant collection with computed values
   - Used by other ML components for enhanced recommendations
   - Example: Restaurant.sentimentScore = 0.65 (positive sentiment)

WHY SCORES ARE IMPORTANT:
- Provides nuanced understanding beyond star ratings
- Identifies restaurants with consistently positive experiences
- Helps filter out restaurants with negative sentiment trends
- Adds emotional intelligence to recommendations

CONTRIBUTION TO APPLICATION:
- Enhances restaurant ranking with sentiment insights
- Provides qualitative feedback analysis
- Improves recommendation trustworthiness
- Supports review-based filtering

TECHNICAL NOTES:
- Uses pre-trained VADER lexicon
- Handles informal language and social media text
- Updates sentiment scores in real-time
- Stores results back to database for caching

================================================================================

6. DASHBOARD RECOMMENDER (dashboard_recommender.py)
================================================================================

WHAT IT IS:
An intelligent meal planning system that provides context-aware food 
recommendations based on time of day, consumed calories, and meal progression.

WHY IT'S USED:
- Provides meal-specific recommendations (breakfast, lunch, dinner, snacks)
- Supports calorie tracking and management
- Considers daily meal progression
- Offers practical, actionable suggestions

ALGORITHMS USED:
1. Time-Based Meal Classification
2. Calorie Budget Management
3. Content-Based Filtering with Contextual Constraints
4. Diversity Optimization

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. User Context Analysis:
   - consumed_calories: Current day's calorie intake from CalorieLog collection
   - calorie_goal: User.preferences.calorieGoal (default: 2000)
   - remaining_calories = calorie_goal - consumed_calories
   - current_hour: System time for meal type determination

2. Meal Type Intelligence:
   - Queries CalorieLog.mealType for today's logged meals
   - Time-based logic:
     * current_hour < 11 AND "breakfast" not logged → suggest "breakfast"
     * 11 ≤ current_hour < 17 AND "lunch" not logged → suggest "lunch"
     * current_hour ≥ 17 AND "dinner" not logged → suggest "dinner"
     * All main meals logged → suggest "snack"

3. Menu Item Filtering:
   - Uses meal-specific keyword matching on MenuItem.name
   - breakfast: ["idli", "dosa", "pongal", "upma", "uttapam", "vada", "poori"]
   - lunch: ["meals", "biryani", "curry", "rice", "sambar", "rasam"]
   - dinner: ["curry", "rice", "biryani", "chapati", "naan", "dal"]
   - snack: ["fry", "tikka", "chaat", "samosa", "pakora"]
   - Regex pattern: MenuItem.name matches meal-type keywords

4. Multi-Criteria Scoring:
   Base Score = 0.6 × Content_Similarity + 0.4 × (Restaurant.rating / 5.0)
   
   Contextual Adjustments:
   - Calorie Fit Bonus: +0.2 if MenuItem.calories ≤ remaining_calories
   - Health Penalties:
     * Diabetes: -0.15 if ("diabetes" in User.health.conditions AND MenuItem.calories > 300)
     * Blood Pressure: -0.1 if ("bp" in User.health.conditions AND MenuItem.spicinessLevel ≥ 4)
   - Balanced Portion Bonus: +0.1 if 150 ≤ MenuItem.calories ≤ 400

5. Diversity Optimization:
   - Alternates between vegetarian (MenuItem.isVeg = true) and non-vegetarian items
   - Prevents duplicate dishes using MenuItem.name similarity
   - Maximum 3 items per dietary category
   - Returns top 6 diverse recommendations

WHY SCORES ARE IMPORTANT:
- Ensures recommendations fit user's daily nutrition plan
- Balances taste preferences with health goals
- Provides meal-appropriate suggestions

CONTRIBUTION TO APPLICATION:
- Powers the main dashboard recommendations
- Supports calorie tracking functionality
- Enables intelligent meal planning
- Provides personalized daily nutrition guidance

TECHNICAL NOTES:
- Implements meal-type specific food filtering
- Ensures dietary diversity (alternates veg/non-veg)
- Handles edge cases (no remaining calories, etc.)
- Returns structured JSON for frontend consumption

================================================================================

7. LOCATION-BASED RANKING (location_ranking.py)
================================================================================

WHAT IT IS:
A geospatial recommendation system that ranks restaurants based on proximity
to user location combined with quality metrics.

WHY IT'S USED:
- Provides practical, actionable recommendations
- Considers delivery feasibility and convenience
- Balances distance with restaurant quality
- Supports location-aware mobile experience

ALGORITHMS USED:
1. Haversine Distance Formula for geospatial calculations
2. Multi-Criteria Scoring (Distance + Quality)
3. Normalization and Weighted Combination

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Geospatial Distance Calculation:
   - User Location: {lat: 11.0168, lon: 76.9558} (Coimbatore coordinates)
   - Restaurant Location: Restaurant.location.latitude, Restaurant.location.longitude
   - Haversine Formula Implementation:
     * R = 6371 km (Earth's radius)
     * Δlat = radians(restaurant.lat - user.lat)
     * Δlon = radians(restaurant.lon - user.lon)
     * a = sin²(Δlat/2) + cos(user.lat) × cos(restaurant.lat) × sin²(Δlon/2)
     * distance = 2R × arcsin(√a)
   - Example: Restaurant at (11.0500, 76.9800) → ~4.2 km from user

2. Distance Score Normalization:
   - Formula: Distance_Score = max(0, 1 - (distance_km / 10))
   - 10 km threshold for maximum delivery range
   - Examples:
     * 0 km distance → 1.0 score (perfect proximity)
     * 5 km distance → 0.5 score (moderate distance)
     * 10+ km distance → 0.0 score (too far)

3. Quality Score Composition:
   - Restaurant.rating: 1-5 star scale from aggregated reviews
   - Restaurant.sentimentScore: -1 to +1 from sentiment analysis
   - Formula: Quality_Score = (Restaurant.rating / 5.0) + Restaurant.sentimentScore
   - Example: 4.2-star restaurant with +0.3 sentiment → 0.84 + 0.3 = 1.14 quality score

4. Final Weighted Score:
   Final_Score = 0.6 × Quality_Score + 0.4 × Distance_Score
   - Prioritizes quality (60%) over proximity (40%)
   - Example calculation:
     * Quality: 4.5 stars + 0.2 sentiment = 1.1
     * Distance: 3 km → 0.7 distance score
     * Final: 0.6 × 1.1 + 0.4 × 0.7 = 0.66 + 0.28 = 0.94

WHY SCORES ARE IMPORTANT:
- Balances convenience (proximity) with quality
- Ensures recommendations are practically accessible
- Optimizes user satisfaction vs. effort trade-off

CONTRIBUTION TO APPLICATION:
- Enables location-based restaurant discovery
- Supports "nearby restaurants" feature
- Optimizes delivery time and cost
- Provides geographically relevant suggestions

TECHNICAL NOTES:
- Uses accurate Haversine formula for Earth's curvature
- Handles missing coordinate data gracefully
- Configurable distance threshold (currently 10km)
- Integrates with sentiment analysis results

================================================================================

8. PERSONALIZED RE-RANKING (personalized_rerank.py)
================================================================================

WHAT IT IS:
A personalization layer that re-ranks generic recommendations based on 
individual user preferences and interaction history.

WHY IT'S USED:
- Adds personalization to any recommendation list
- Learns from user behavior patterns
- Improves recommendation relevance over time
- Provides user-specific preference modeling

ALGORITHMS USED:
1. User Profile Embedding Generation
2. TF-IDF Item Representation
3. Cosine Similarity for User-Item Matching
4. Weighted Score Combination

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. User Profile Construction:
   - Identifies user's reviewed restaurants from Review.userId
   - Maps Review.restaurantId to MenuItem.restaurantId
   - Collects all menu items from user's reviewed restaurants
   - Creates user preference vector from interacted items

2. Item Representation:
   - Each MenuItem converted to TF-IDF vector
   - Text features: MenuItem.name + MenuItem.description + MenuItem.cuisine
   - Example: "Chicken Biryani Aromatic basmati rice South Indian"
   - Vector dimensions: [vocabulary_size] (typically 1000-5000 features)

3. User Embedding Generation:
   - User_Vector = Average(TF-IDF_vectors of user's interacted items)
   - Formula: User_Profile = (1/n) × Σ(Item_Vectors)
   - Where n = number of user interactions
   - Example: User who reviewed 5 restaurants → average of 5 item vectors

4. User-Item Similarity:
   - Cosine similarity between User_Vector and each MenuItem vector
   - Formula: Similarity = (User_Vector · Item_Vector) / (||User_Vector|| × ||Item_Vector||)
   - Range: 0.0 to 1.0 (1.0 = perfect match to user preferences)

5. Hybrid Score Integration:
   - Combines content-based similarity with user personalization
   - Final_Score = 0.6 × Hybrid_Base_Score + 0.4 × User_Similarity_Score
   - Balances general item quality with personal preference matching
   - Example: High-quality item (0.8) + good personal match (0.9) = 0.84 final score

WHY SCORES ARE IMPORTANT:
- Captures individual user preferences
- Improves recommendation accuracy over time
- Enables preference-based filtering and ranking

CONTRIBUTION TO APPLICATION:
- Personalizes all recommendation outputs
- Learns user preferences automatically
- Improves user engagement and satisfaction
- Supports long-term user retention

TECHNICAL NOTES:
- Builds user profiles from interaction history
- Handles new users with default profiles
- Updates profiles incrementally
- Maintains user privacy (no explicit profiling)

================================================================================

9. USER PROFILE EMBEDDING (user_profile_embedding.py)
================================================================================

WHAT IT IS:
A user modeling system that creates numerical representations of user 
preferences based on their interaction history with restaurants and menu items.

WHY IT'S USED:
- Enables mathematical representation of user preferences
- Supports similarity calculations between users
- Provides foundation for personalized recommendations
- Captures implicit user preferences

ALGORITHMS USED:
1. TF-IDF Vectorization of interacted items
2. Vector Averaging for profile aggregation
3. Dimensionality Reduction through averaging

HOW SCORES ARE CALCULATED:
1. Item Representation:
   Each menu item → TF-IDF vector based on text features

2. User Profile:
   User_Profile = (1/n) × Σ(TF-IDF_vectors of user's interacted items)
   Where n = number of interactions

3. Profile Quality:
   Based on number of interactions and diversity of choices

WHY SCORES ARE IMPORTANT:
- Enables user-to-user similarity calculations
- Supports cold start problem mitigation
- Provides interpretable user preference representation

CONTRIBUTION TO APPLICATION:
- Powers personalized recommendation algorithms
- Enables user clustering and segmentation
- Supports A/B testing of recommendation strategies
- Provides user analytics insights

TECHNICAL NOTES:
- Handles sparse interaction data
- Normalizes for users with different activity levels
- Updates profiles incrementally
- Maintains consistent vector dimensions

================================================================================

10. MENU EMBEDDINGS & RETRIEVAL (build_menu_embeddings.py, retrieve_menu.py)
================================================================================

WHAT IT IS:
A semantic search system that creates searchable embeddings of menu items
and enables fast similarity-based retrieval for query matching.

WHY IT'S USED:
- Enables natural language food search
- Supports semantic similarity matching
- Provides fast retrieval for large menu databases
- Powers conversational food discovery

ALGORITHMS USED:
1. TF-IDF Vectorization for text embedding
2. Cosine Similarity for semantic matching
3. Pickle serialization for fast loading

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Menu Item Text Processing:
   - Combines MenuItem.name + MenuItem.description + MenuItem.cuisine
   - Example: "Chicken Biryani" + "Aromatic basmati rice" + "South Indian"
   - Creates comprehensive text representation for each dish
   - Includes Restaurant.name and Restaurant.location.city for context

2. TF-IDF Embedding Generation:
   - Vectorizer processes all menu item texts
   - Creates numerical embeddings capturing semantic meaning
   - Vocabulary size: ~1000-5000 unique food-related terms
   - Each MenuItem gets unique vector representation

3. Query Processing:
   - User query: "I want spicy chicken"
   - Enhanced query adds domain keywords: "spicy chicken meat non-veg"
   - Query converted to TF-IDF vector using same vocabulary

4. Similarity Calculation:
   - Cosine similarity between query vector and all menu item vectors
   - Formula: Similarity = (Query_Vector · Item_Vector) / (||Query|| × ||Item||)
   - Returns similarity scores from 0.0 to 1.0

5. Ranking and Retrieval:
   - Items sorted by similarity score (highest first)
   - Top-K items selected (typically K=5)
   - Returns structured data: dish name, restaurant, price, dietary info
   - Example output: "Chicken Biryani, Saravana Bhavan, ₹250, Non-Veg, Spice: 3"

WHY SCORES ARE IMPORTANT:
- Enables semantic search beyond keyword matching
- Provides relevance ranking for search results
- Supports fuzzy matching for user queries

CONTRIBUTION TO APPLICATION:
- Powers search functionality
- Enables conversational food discovery
- Supports RAG (Retrieval-Augmented Generation) for chatbot
- Provides fast menu exploration

TECHNICAL NOTES:
- Pre-computes embeddings for performance
- Supports incremental updates
- Handles multi-language text processing
- Optimized for real-time retrieval

================================================================================

11. RAG SYSTEM (rag_runner.py)
================================================================================

WHAT IT IS:
A Retrieval-Augmented Generation system that enhances user queries with 
contextual information and retrieves relevant menu items for chatbot responses.

WHY IT'S USED:
- Improves chatbot response accuracy
- Provides contextual food recommendations
- Handles natural language food queries
- Enhances user interaction experience

ALGORITHMS USED:
1. Query Enhancement with domain-specific keywords
2. Semantic Retrieval using pre-built embeddings
3. Context Aggregation for LLM input

HOW SCORES ARE CALCULATED:

DETAILED PARAMETER BREAKDOWN:

1. Query Enhancement Logic:
   - Original Query: "I want something spicy"
   - Diet Detection: Checks for "non veg", "chicken", "mutton" keywords
   - Mood Mapping:
     * "stressed" → adds "curry rice dal"
     * "spicy" → adds "pepper chili masala"
     * "light" → adds "salad soup steamed"
   - Enhanced Query: "I want something spicy pepper chili masala"

2. Semantic Retrieval Process:
   - Uses retrieve_menu.py with enhanced query
   - TF-IDF similarity matching against MenuItem database
   - Returns top 5 most relevant items with metadata

3. Context Aggregation:
   - Formats retrieved items for LLM consumption
   - Structure: "Dish: [name], Restaurant: [restaurant] ([city]), Veg: [boolean], Price: [amount], Spice: [level]"
   - Example context:
     * "Dish: Chicken 65, Restaurant: Saravana Bhavan (Coimbatore), Veg: false, Price: 180, Spice: 4"
     * "Dish: Mutton Curry, Restaurant: Anjappar (Coimbatore), Veg: false, Price: 220, Spice: 3"

4. LLM Integration:
   - Context passed to Google Gemini API
   - Enables informed, contextual responses about available food options
   - Supports natural conversation about food preferences and availability

WHY SCORES ARE IMPORTANT:
- Ensures most relevant items are retrieved
- Provides quality context for LLM responses
- Improves chatbot accuracy and helpfulness

CONTRIBUTION TO APPLICATION:
- Powers intelligent chatbot responses
- Enables natural language food discovery
- Provides contextual recommendations in conversations
- Supports complex query understanding

TECHNICAL NOTES:
- Integrates with Google Gemini API
- Handles mood-based and dietary queries
- Supports real-time query processing
- Extensible keyword mapping system

================================================================================
                              SYSTEM INTEGRATION
================================================================================

DATA FLOW:
1. User interactions → Reviews/Ratings → Collaborative Filtering
2. Menu items → Content analysis → Content-Based Filtering  
3. User health profile → Health constraints → Health-Aware Filtering
4. Review text → Sentiment Analysis → Restaurant quality scores
5. All components → Hybrid Recommender → Final recommendations
6. User location → Location Ranking → Proximity-based filtering
7. User queries → RAG System → Contextual responses

PERFORMANCE OPTIMIZATIONS:
- Pre-computed embeddings for fast retrieval
- Cached similarity matrices
- Incremental profile updates
- Efficient database queries
- Normalized scoring for consistent performance

SCALABILITY CONSIDERATIONS:
- Modular architecture allows independent scaling
- Database-agnostic design (MongoDB currently)
- Stateless recommendation functions
- Batch processing capabilities for large datasets

EVALUATION METRICS:
- Recommendation Accuracy (precision, recall, F1-score)
- User Engagement (click-through rates, session duration)
- Health Goal Achievement (calorie adherence, dietary compliance)
- System Performance (response time, throughput)

================================================================================
                              INNOVATION ASPECTS
================================================================================

1. HYBRID APPROACH: Combines multiple ML techniques for robust recommendations
2. HEALTH AWARENESS: Integrates medical and nutritional constraints
3. CONTEXT SENSITIVITY: Considers time, location, and meal progression
4. SENTIMENT INTEGRATION: Uses NLP for qualitative restaurant assessment
5. REAL-TIME ADAPTATION: Updates recommendations based on current context
6. CONVERSATIONAL AI: RAG system for natural language food discovery

================================================================================
                              FUTURE ENHANCEMENTS
================================================================================

1. Deep Learning Models: Neural collaborative filtering, autoencoders
2. Real-time Learning: Online learning algorithms for immediate adaptation
3. Multi-modal Data: Image recognition for food photos
4. Advanced NLP: Transformer models for better text understanding
5. Federated Learning: Privacy-preserving collaborative filtering
6. Reinforcement Learning: Adaptive recommendation strategies

================================================================================

This comprehensive ML architecture demonstrates advanced understanding of
recommendation systems, machine learning algorithms, and practical application
development. The system successfully combines multiple AI techniques to create
a sophisticated, health-aware, and context-sensitive food recommendation
platform suitable for real-world deployment.

================================================================================